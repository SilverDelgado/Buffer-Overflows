\chapter{SOLUCIONES}

\section{Soluciones generales}
\noindent Los desbordamientos de búfer representan una amenaza seria en el desarrollo de software, especialmente en lenguajes de bajo nivel como C, que no realiza verificaciones automáticas de los límites de la memoria. 
\\
A continuación, se presentan una serie de prácticas y herramientas que se utilizan ampliamente para prevenir y gestionar eficazmente los desbordamientos de búfer:

\begin{enumerate}
    \item \textbf{Uso de Funciones de Manipulación de Cadenas Seguras}
    \\
    Las funciones de manipulación de cadenas en C, como \verb|strcpy|, \verb|sprintf|, y \verb|strcat|, son conocidas por su vulnerabilidad a desbordamientos de búfer, ya que no tienen en cuenta los límites de la memoria asignada para las cadenas destino. Para minimizar el riesgo de desbordamiento de búfer y mejorar la seguridad del código, es fundamental adoptar funciones seguras que permitan controlar la cantidad de datos que se copian o concatenan en cada operación. Funciones como \verb|strncpy| y \verb|snprintf|, que permiten especificar la longitud máxima de los datos a copiar o formatear, son alternativas más seguras que deberían ser preferidas siempre que sea posible. También existen bibliotecas modernas y funciones especializadas en manipulación de cadenas seguras que están diseñadas específicamente para reducir este riesgo.

    \item \textbf{Validación de la Longitud de las Entradas}
    \\
    Validar la longitud de las entradas antes de almacenarlas en búferes de tamaño fijo es una práctica esencial en el desarrollo seguro de software. Esto implica verificar que los datos ingresados por el usuario o provenientes de otras fuentes externas no excedan la capacidad del búfer, evitando así la sobrescritura de áreas de memoria adyacentes. Esta validación debe hacerse tanto en tiempo de compilación como en tiempo de ejecución para garantizar que el programa funcione correctamente bajo condiciones normales y ante entradas inesperadas. En algunos casos, es conveniente establecer límites de longitud fijos y claros en la especificación del programa para facilitar esta tarea.

    \item \textbf{Asignación Dinámica de Memoria (cuando es posible)}
    \\
    La asignación dinámica de memoria mediante funciones como \verb|malloc|, \verb|calloc|, y \verb|realloc| en C permite al programa ajustar el tamaño del búfer de acuerdo con la cantidad de datos que necesita manejar en tiempo de ejecución. Esto reduce el riesgo de desbordamientos de búfer, ya que el tamaño de la memoria puede aumentar según la demanda del programa, en lugar de depender de un tamaño estático. Sin embargo, es importante recordar que un uso incorrecto de la memoria dinámica puede introducir otros problemas de seguridad, como filtraciones de memoria (\textit{memory leaks}) o uso de memoria no inicializada. Para evitar esto, los desarrolladores deben asegurarse de liberar correctamente la memoria asignada con \verb|free| después de que ya no sea necesaria y de inicializar adecuadamente cualquier memoria asignada.

    \item \textbf{Control y Seguimiento del Uso de Memoria}
    \\
    Monitorear y controlar el uso de la memoria del programa es otra estrategia efectiva para prevenir desbordamientos de búfer. Existen herramientas de análisis y depuración de memoria, como \textit{Valgrind}, que permite detectar posibles errores de memoria, incluyendo accesos fuera de los límites del búfer y uso de memoria sin inicializar. Estas herramientas pueden integrarse en el flujo de trabajo de desarrollo y ejecutarse durante pruebas exhaustivas para detectar y corregir vulnerabilidades antes de la fase de producción. Además, muchas herramientas de análisis de memoria proporcionan información detallada sobre el estado del programa, lo que permite identificar fácilmente áreas del código propensas a desbordamientos de búfer.

    \item \textbf{Desarrollo Seguro y Prácticas de Programación Defensiva}
    \\
    Implementar prácticas de programación defensiva y seguir principios de desarrollo seguro es fundamental para reducir el riesgo de desbordamiento de búfer y otros errores de seguridad. Esto incluye escribir código robusto que prevea posibles condiciones de error y situaciones de uso inesperadas, de modo que el programa responda de manera controlada y segura. La programación defensiva también implica una revisión constante del código para verificar que no existan accesos indebidos a la memoria y que los límites de los búferes se respeten en todas las operaciones de lectura y escritura. Además, el uso de revisiones de código y auditorías de seguridad puede ayudar a identificar problemas de memoria y prácticas inseguras en el código, lo cual es una excelente práctica para reducir errores en etapas tempranas del desarrollo.

\end{enumerate}


\section{Solución específica}
\noindent Para solucionar el buffer overflow en este programa, tendremos en cuenta los fallos que se han cometido hasta ahora:

\begin{enumerate}
    \item \textbf{No tener en cuenta el caracter nulo.}
    \item \textbf{Uso de función de copia de string insegura}\textbf{, no se controla el máximo de lectura}

\end{enumerate}
\noindent \textbf{1.} Vamos a modificar el código de tal forma que qfoo tenga espacio para 9 + 1 caracteres, incluyendo así el caracter nulo.
\begin{verbatim}
int
main ()
{
  char qfoo[9+1]; //Incluyendo caracter nulo
  char q0[9+1]; //Incluyendo caracter nulo
  int qbar = 0;
  char qbaz;
\end{verbatim}
\newpage \noindent
\textbf{2.} Ahora vamos a modificar el bucle while donde se lee de tal forma que no se pueda escribir más de lo que se debería en qfoo.
\begin{verbatim}
#include <stdio.h>
#include <string.h>
int
main ()
{
  char qfoo[9+1]; //Incluyendo caracter nulo
  char q0[9+1]; //Incluyendo caracter nulo
  int qbar = 0;
  char qbaz;
  printf
    ("Introduce el DNI caracter a caracter y presiona 
    Enter para terminar):\n");
  while ((qbaz = getchar ()) != '\n' && qbar<9) //Para que no 
  //se escriba más de 9 caracteres de DNI
    {
      qfoo[qbar++] = qbaz;
    }
  qfoo[qbar] = '\0';
  strcpy (q0, qfoo);
  printf ("El DNI introducido es: %s\n", q0);
  return 0;
}
\end{verbatim}

\noindent Por úiltimo vamos a pasarle valgrind para ver si se encuentra algún error.
Introduce el DNI caracter a caracter y presiona Enter para terminar): 
\\
999999999999999999999999999999999999999999999999999 
\\
El DNI introducido es: 999999999 
\\
==4366== HEAP SUMMARY: 
\\
==4366==     in use at exit: 0 bytes in 0 blocks 
\\
==4366==   total heap usage: 2 allocs, 2 frees, 2,048 bytes allocated 
\\
==4366==  
\\
==4366== All heap blocks were freed -- no leaks are possible 
\\
==4366==  
\\
\textbf{==4366== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)}
\\
Podemos observar que \textbf{no ocurre ningún error} ahora tras escribir de más.

\afterpage{\blankpage}

                          
 
